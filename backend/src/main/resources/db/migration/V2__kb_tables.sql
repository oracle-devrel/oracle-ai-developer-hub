-- liquibase formatted sql
-- Knowledge Base (RAG) schema: documents, chunks, embeddings, and vector index
-- Adjust VECTOR(...) DDL to match your Oracle AI Database version and embedding dimension.

-- changeset victor:kb_1_drop endDelimiter:/
-- comment: Drop existing KB objects if present (idempotent)
DECLARE
  v_drop BOOLEAN := TRUE; -- Set to FALSE to skip dropping existing objects
BEGIN
  IF v_drop THEN
    -- Drops in reverse order (dependencies first)
    BEGIN EXECUTE IMMEDIATE 'DROP VIEW kb_chunks_with_docs'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP VECTOR INDEX kb_vec_idx'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP TABLE kb_embeddings CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP INDEX idx_kb_chunks_tenant_doc'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP INDEX idx_kb_chunks_doc_ix'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP TABLE kb_chunks CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP INDEX idx_kb_docs_tenant_active'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP TABLE kb_documents CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF;
END;
/
-- rollback SELECT 1 FROM DUAL;

-- changeset victor:kb_2_docs_table
CREATE TABLE kb_documents (
  doc_id        VARCHAR2(128) PRIMARY KEY,
  tenant_id     VARCHAR2(64) NOT NULL,
  title         VARCHAR2(256),
  uri           VARCHAR2(1024),         -- source URI (e.g., oci://bucket/prefix/file.pdf)
  mime          VARCHAR2(128),
  version       VARCHAR2(64),
  tags_json     JSON,
  hash          VARCHAR2(128),          -- content hash for idempotent ingestion
  active        NUMBER(1) DEFAULT 1,
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL
);
-- rollback DROP TABLE kb_documents;

-- changeset victor:kb_3_docs_index
CREATE INDEX idx_kb_docs_tenant_active ON kb_documents(tenant_id, active);
-- rollback DROP INDEX idx_kb_docs_tenant_active;

-- changeset victor:kb_4_chunks_table
CREATE TABLE kb_chunks (
  id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  doc_id       VARCHAR2(128) NOT NULL,
  tenant_id    VARCHAR2(64) NOT NULL,
  chunk_ix     NUMBER NOT NULL,
  text         CLOB,
  source_meta  JSON,
  CONSTRAINT fk_kb_chunks_doc
    FOREIGN KEY (doc_id) REFERENCES kb_documents(doc_id)
);
-- rollback DROP TABLE kb_chunks;

-- changeset victor:kb_5_chunks_idx1
CREATE INDEX idx_kb_chunks_doc_ix ON kb_chunks(doc_id, chunk_ix);
-- rollback DROP INDEX idx_kb_chunks_doc_ix;

-- changeset victor:kb_6_chunks_idx2
CREATE INDEX idx_kb_chunks_tenant_doc ON kb_chunks(tenant_id, doc_id);
-- rollback DROP INDEX idx_kb_chunks_tenant_doc;

-- changeset victor:kb_7_embeddings_table
-- Embeddings table; DIMENSION must match the embedding model used (e.g., 1024 for cohere.embed-english-3)
-- Use FLOAT32 for compactness; adjust if your DB version requires different syntax.
CREATE TABLE kb_embeddings (
  chunk_id     NUMBER PRIMARY KEY,
  embedding    VECTOR(1024, FLOAT32), -- adjust 1024 to your embedding dimension
  CONSTRAINT fk_kb_embeddings_chunk
    FOREIGN KEY (chunk_id) REFERENCES kb_chunks(id)
);
-- rollback DROP TABLE kb_embeddings;

-- changeset victor:kb_8_embeddings_vec_index splitStatements:false endDelimiter:/
-- Create a vector index for ANN search. Tries multiple syntaxes; ignores errors on unsupported features.
DECLARE
  v_sql VARCHAR2(4000);
BEGIN
  -- Try HNSW with ACCURACY + COSINE
  BEGIN
    v_sql := 'CREATE VECTOR INDEX kb_vec_idx ON kb_embeddings(embedding) ORGANIZATION HNSW WITH ACCURACY 100 DISTANCE COSINE';
    EXECUTE IMMEDIATE v_sql;
    RETURN;
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  -- Try IVF with ACCURACY + COSINE
  BEGIN
    v_sql := 'CREATE VECTOR INDEX kb_vec_idx ON kb_embeddings(embedding) ORGANIZATION IVF WITH ACCURACY 100 DISTANCE COSINE';
    EXECUTE IMMEDIATE v_sql;
    RETURN;
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  -- Try HNSW with L2
  BEGIN
    v_sql := 'CREATE VECTOR INDEX kb_vec_idx ON kb_embeddings(embedding) ORGANIZATION HNSW WITH ACCURACY 100 DISTANCE L2';
    EXECUTE IMMEDIATE v_sql;
    RETURN;
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  -- Try IVF with L2
  BEGIN
    v_sql := 'CREATE VECTOR INDEX kb_vec_idx ON kb_embeddings(embedding) ORGANIZATION IVF WITH ACCURACY 100 DISTANCE L2';
    EXECUTE IMMEDIATE v_sql;
    RETURN;
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  -- Older style (if supported) - USING + WITH(...) form
  BEGIN
    v_sql := 'CREATE VECTOR INDEX kb_vec_idx ON kb_embeddings(embedding) USING HNSW WITH (accuracy=100, distance=cosine)';
    EXECUTE IMMEDIATE v_sql;
    RETURN;
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  -- If none worked, continue without vector index
  NULL;
END;
/
-- rollback DROP VECTOR INDEX kb_vec_idx;

-- changeset victor:kb_9_view
-- Helpful view joining chunks and docs
CREATE OR REPLACE VIEW kb_chunks_with_docs AS
SELECT c.id AS chunk_id,
       c.doc_id,
       d.title,
       d.uri,
       d.tags_json,
       c.tenant_id,
       c.chunk_ix,
       c.text,
       c.source_meta
  FROM kb_chunks c
  JOIN kb_documents d ON d.doc_id = c.doc_id;
-- rollback DROP VIEW kb_chunks_with_docs;
